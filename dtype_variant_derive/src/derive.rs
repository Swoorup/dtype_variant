#![allow(non_snake_case)]

use darling::{FromAttributes as _, FromDeriveInput};
use indexmap::{IndexMap, IndexSet};
use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::{format_ident, quote};
use syn::spanned::Spanned;
use syn::{Attribute, Data, Error, Expr, Field, Generics, Ident, Path};
use syn::{
    DataEnum, DeriveInput, Fields, GenericArgument, PathArguments, Type,
    TypePath, WhereClause, parse_macro_input, parse_quote,
};

use crate::dtype_variant_path;
use crate::grouped_matcher::{DTypeGroupedMatcherArgs, ParsedGroupedMatcher};
use crate::matcher_gen::{MacroRuleArm, generate_macro_rule_arm};

//============================================================================
// Error Handling Utilities
//============================================================================

/// Creates a standardized error message for proc macro errors.
/// Uses consistent formatting with backticks for code identifiers.
fn create_error_message(context: &str, details: &str) -> String {
    format!("{}: {}", context, details)
}

/// Combines multiple syn::Error instances into a single error.
/// Provides a consistent way to accumulate and report multiple validation errors.
fn combine_errors(base_error: Option<Error>, new_error: Error) -> Error {
    match base_error {
        Some(mut existing) => {
            existing.combine(new_error);
            existing
        }
        None => new_error,
    }
}

/// Converts a darling::Error to syn::Error with consistent formatting.
fn darling_error_to_syn(darling_error: darling::Error) -> Error {
    Error::new(darling_error.span(), darling_error.to_string())
}

//============================================================================
// Configuration and Data Structures
//============================================================================

/// Parses the top-level `#[dtype(...)]` attribute applied to the enum.
#[derive(Debug, FromDeriveInput)]
#[darling(attributes(dtype), supports(enum_any))] // Specify attribute name and support only enums
struct DTypeMacroArgs {
    /// The identifier of the enum (e.g., `MyEnum`).
    ident: Ident,
    /// The generic parameters of the enum (e.g., `<'a, T: Bound>`).
    generics: Generics,
    /// The body of the enum (variants and fields).
    /// Uses darling::ast::Data for potential future integration with variant/field attributes.
    // data: DarlingData<NestedVariant, NestedField>,

    // --- Configuration Fields ---
    /// **Optional.** Path to the module containing shared variant ZST types generated by `build_dtype_tokens`.
    /// When not specified, variant ZST types are generated in the same location as the enum.
    /// Example: `"my_crate::tokens::MyTokens"`
    #[darling(default)]
    shared_variant_zst_path: Option<Path>,

    /// Optional. Identifier of the container type wrapping variant payloads.
    /// Example: `"Vec"`, `"Box"`
    #[darling(default)]
    container: Option<Ident>,

    /// Optional. Path to a trait that inner types of variants must implement.
    /// Example: `"my_crate::constraints::MyConstraint"`
    #[darling(default)]
    constraint: Option<Expr>,

    /// Optional. Identifier for the name of the generated closure-based matcher method.
    /// Example: `"match_variant"`
    #[darling(default)]
    matcher: Option<Ident>,

    /// Optional. If true, skips generating From impls for the enum variants.
    #[darling(default)]
    skip_from_impls: bool,
}

/// Comprehensive information about a parsed enum variant.
/// 
/// This structure contains all the metadata and generated code needed for a single
/// enum variant, including struct definitions for struct variants and type information
/// for all variant types.
#[derive(Debug, Clone)]
pub struct ParsedVariantInfo {
    /// Identifier of the enum variant (e.g., `MyVariant`).
    pub variant_ident: Ident,
    /// Identifier of the corresponding token (e.g., `MyVariantVariant`).
    pub token_ident: Ident,
    /// The full type of the field in a tuple variant (e.g., `Vec<u16>` or `f64`).
    /// For struct variants, this will be the generated struct type.
    /// `None` for unit variants.
    pub full_field_type: Option<Type>,
    /// The inner payload type (e.g., `u16` from `Vec<u16>`, or `f64` if no container).
    /// For struct variants, this will be the generated struct type.
    /// `None` for unit variants.
    pub inner_type: Option<Type>,
    /// True if this is a unit variant (e.g., `MyUnitVariant`).
    pub is_unit: bool,
    /// True if this is a struct variant (e.g., `MyVariant { field: Type }`).
    pub is_struct: bool,
    /// Generated struct definition for struct variants. `None` for non-struct variants.
    pub struct_definition: Option<TokenStream2>,
    /// Generated reference struct definition for struct variants. `None` for non-struct variants.
    pub struct_ref_definition: Option<TokenStream2>,
    /// Generated mutable reference struct definition for struct variants. `None` for non-struct variants.
    pub struct_mut_definition: Option<TokenStream2>,
    /// The reference struct type for struct variants. `None` for non-struct variants.
    pub ref_type: Option<Type>,
    /// The mutable reference struct type for struct variants. `None` for non-struct variants.
    pub mut_type: Option<Type>,
    /// Field information for struct variants. `None` for non-struct variants.
    pub struct_fields: Option<Vec<Field>>,
}

//============================================================================
// Main Entry Point
//============================================================================

/// Main implementation of the DType derive macro.
/// 
/// This function processes the input enum and generates all necessary code for:
/// - Variant token types (either locally or using shared tokens)
/// - Struct definitions for struct variants
/// - Downcast trait implementations (owned, reference, and mutable reference)
/// - From trait implementations
/// - Pattern matching macros (regular and grouped)
/// 
/// # Arguments
/// * `input` - TokenStream from the derive macro containing the enum definition
/// 
/// # Returns
/// * TokenStream containing all generated code
/// 
/// # Errors
/// Returns compilation errors for:
/// - Non-enum types
/// - Invalid attribute configurations
/// - Malformed grouped matcher definitions
/// - Missing shared variant tokens
pub fn dtype_derive_impl(input: TokenStream) -> TokenStream {
    let dtype_variant_path = dtype_variant_path();

    // Parse the input token stream into a syn::DeriveInput AST node.
    let derive_input = parse_macro_input!(input as DeriveInput);

    // Parse the #[dtype(...)] attributes using darling.
    let main_args = match DTypeMacroArgs::from_derive_input(&derive_input) {
        Ok(args) => args,
        Err(e) => return e.write_errors().into(),
    };

    // Perform initial validation: ensure it's an enum.
    let enum_data = match &derive_input.data {
        Data::Enum(data) => data,
        _ => {
            return Error::new_spanned(
                &main_args.ident,
                create_error_message(
                    "DType derive macro validation", 
                    "can only be used on `enum` types"
                ),
            )
            .to_compile_error()
            .into();
        }
    };

    // Parse string paths from darling config into syn types.
    let parse_result = parse_config_paths(&main_args);
    let ParsedPaths {
        shared_variant_zst_path_opt,
        container_ident_opt,
        constraint_path_opt,
        matcher_ident_opt,
    } = match parse_result {
        Ok(paths) => paths,
        Err(e) => return e.to_compile_error().into(),
    };

    // Determine tokens path - use shared_variant_zst_path if specified, otherwise generate locally
    let (tokens_path, generate_local_tokens) = match shared_variant_zst_path_opt {
        Some(path) => (path, false),
        None => {
            // Generate tokens locally - use the current module path
            let local_path: syn::Path = syn::parse_quote!(self);
            (local_path, true)
        }
    };

    // Parse enum variants and extract necessary information
    let parsed_variants = match parse_variants(enum_data, &container_ident_opt, &main_args.ident) {
        Ok(variants) => variants,
        Err(e) => return e.to_compile_error().into(),
    };

    // Parse #[dtype_grouped_matcher] attributes using darling
    let mut parsed_grouped_matchers = Vec::new();
    let mut attr_parse_errors: Option<Error> = None;

    // Filter attributes first
    let grouped_matcher_attrs: Vec<&Attribute> = derive_input
        .attrs
        .iter()
        .filter(|attr| attr.path().is_ident("dtype_grouped_matcher"))
        .collect();

    for attr in grouped_matcher_attrs {
        // Use from_attributes on a slice containing just the current attribute (cloned)
        match DTypeGroupedMatcherArgs::from_attributes(&[attr.clone()]) {
            // from_attributes returns Result<Self> when called on one attribute
            Ok(parsed_args) => {
                // Successfully parsed a single attribute
                parsed_grouped_matchers.push(ParsedGroupedMatcher {
                    macro_name: parsed_args.macro_name,
                    groups: parsed_args.grouping.0, // Extract Vec from ParsedGroups wrapper
                    _span: attr.span(), // Get span from the original syn::Attribute
                });
            }
            Err(e) => {
                // Use standardized error handling
                let syn_error = darling_error_to_syn(e);
                attr_parse_errors = Some(combine_errors(attr_parse_errors, syn_error));
            }
        }
    }

    // If any attribute parsing errors occurred, return them
    if let Some(errors) = attr_parse_errors {
        return errors.to_compile_error().into();
    }

    // Validate parsed grouped matchers
    let mut validation_errors: Option<Error> = None;
    for parsed_matcher in &parsed_grouped_matchers {
        if let Err(e) = validate_grouped_matcher(parsed_matcher, &parsed_variants) {
            validation_errors = Some(combine_errors(validation_errors, e));
        }
    }
    if let Some(errors) = validation_errors {
        return errors.to_compile_error().into();
    }

    // Extract components for code generation.
    let enum_name = &main_args.ident;
    let generics = &main_args.generics;

    // Generate the different code blocks using helper functions.
    let struct_definitions = generate_struct_definitions(&parsed_variants);
    let struct_from_conversions = generate_struct_from_conversions(&parsed_variants, enum_name);
    let local_token_definitions = if generate_local_tokens {
        generate_local_token_definitions(&parsed_variants)
    } else {
        TokenStream2::new()
    };
    let token_validation_code = if !generate_local_tokens {
        generate_token_validation(&tokens_path, &parsed_variants)
    } else {
        TokenStream2::new() // No validation needed for locally generated variant ZST tokens
    };
    let target_impls = generate_enum_variant_downcast(
        &dtype_variant_path,
        enum_name,
        generics,
        &parsed_variants,
        &tokens_path,
    );
    let constraint_impls = generate_enum_variant_constraint(
        &dtype_variant_path,
        enum_name,
        generics,
        &parsed_variants,
        &constraint_path_opt,
        &tokens_path, // Pass tokens_path
    );
    let from_impls = generate_from_impls(
        enum_name,
        generics,
        &parsed_variants,
        container_ident_opt.is_some(),
        &tokens_path,
        main_args.skip_from_impls,
    );
    let downcast_methods = generate_downcast_methods(
        &dtype_variant_path,
        enum_name,
        generics,
        &parsed_variants,
    );
    let matcher_method = generate_matcher_method(
        &dtype_variant_path,
        enum_name,
        generics,
        &parsed_variants,
        &matcher_ident_opt,
        &tokens_path,
    );
    let grouped_matcher_macro = parsed_grouped_matchers
        .iter() // Iterate over references
        .map(|parsed_grouped_matcher| {
            // Use the reference here
            generate_grouped_matcher_macro(
                &dtype_variant_path,
                enum_name,
                generics, // Pass generics
                &parsed_variants,
                parsed_grouped_matcher, // Pass the reference
                &tokens_path,
            )
        })
        .fold(TokenStream2::new(), |mut acc, s| {
            // Use TokenStream2::new() and make acc mutable
            acc.extend(s); // Use extend instead of +
            acc
        });

    // Combine generated code fragments.
    let final_code = quote! {
        // Generated local variant ZST types (if not using shared path).
        #local_token_definitions

        // Generated struct definitions for struct variants.
        #struct_definitions

        // Generated From conversions for struct reference types.
        #struct_from_conversions

        // Compile-time validation of shared variant ZST token existence.
        #token_validation_code

        // Implementations of #dtype_variant_path::EnumVariantTarget trait.
        #target_impls

        // Implementations of the user-specified constraint trait.
        #constraint_impls

        // Implementations of From<PayloadType> for the enum.
        #from_impls

        // Implementation block containing downcast methods.
        #downcast_methods

        // Implementation block containing the matcher method.
        #matcher_method

        // Implementation block containing the grouped matcher macro.
        #grouped_matcher_macro
    };

    // Return the final generated code.
    final_code.into()
}

//============================================================================
// Parsing and Validation Functions
//============================================================================

/// Parses string paths/identifiers from the darling config struct into syn types.
#[derive(Default)]
struct ParsedPaths {
    shared_variant_zst_path_opt: Option<Path>,
    container_ident_opt: Option<Ident>,
    constraint_path_opt: Option<Expr>,
    matcher_ident_opt: Option<Ident>,
}

fn parse_config_paths(args: &DTypeMacroArgs) -> Result<ParsedPaths, Error> {
    let shared_variant_zst_path: Option<Path> = args.shared_variant_zst_path.clone();
    let container_ident: Option<Ident> = args.container.clone();
    let constraint_path: Option<Expr> = args.constraint.clone();
    let matcher_ident: Option<Ident> = args.matcher.clone();

    Ok(ParsedPaths {
        shared_variant_zst_path_opt: shared_variant_zst_path,
        container_ident_opt: container_ident,
        constraint_path_opt: constraint_path,
        matcher_ident_opt: matcher_ident,
    })
}
/// Parses enum variants, extracting types and validating structure.
fn parse_variants(
    enum_data: &DataEnum,
    container_ident: &Option<Ident>,
    enum_name: &Ident,
) -> Result<Vec<ParsedVariantInfo>, Error> {
    let mut variants_info = Vec::new();

    for variant in &enum_data.variants {
        let variant_ident = variant.ident.clone();
        // Assume token identifier is VariantNameVariant (adjust if needed).
        let token_ident = format_ident!(
            "{}Variant",
            variant_ident,
            span = variant_ident.span()
        );

        match &variant.fields {
            Fields::Unit => {
                variants_info.push(ParsedVariantInfo {
                    variant_ident,
                    token_ident,
                    full_field_type: None,
                    inner_type: None,
                    is_unit: true,
                    is_struct: false,
                    struct_definition: None,
                    struct_ref_definition: None,
                    struct_mut_definition: None,
                    ref_type: None,
                    mut_type: None,
                    struct_fields: None,
                });
            }
            Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {
                let field = fields.unnamed.first().unwrap();
                let full_field_type = field.ty.clone();
                let inner_type =
                    extract_inner_type(&full_field_type, container_ident)?;

                variants_info.push(ParsedVariantInfo {
                    variant_ident,
                    token_ident,
                    full_field_type: Some(full_field_type),
                    inner_type: Some(inner_type),
                    is_unit: false,
                    is_struct: false,
                    struct_definition: None,
                    struct_ref_definition: None,
                    struct_mut_definition: None,
                    ref_type: None,
                    mut_type: None,
                    struct_fields: None,
                });
            }
            Fields::Named(named_fields) => {
                // Handle struct variants - generate struct types for the fields
                let struct_ident = format_ident!(
                    "{}{}Fields",
                    enum_name,
                    variant_ident,
                    span = variant_ident.span()
                );
                let struct_ref_ident = format_ident!(
                    "{}{}Ref",
                    enum_name,
                    variant_ident,
                    span = variant_ident.span()
                );
                let struct_mut_ident = format_ident!(
                    "{}{}Mut",
                    enum_name,
                    variant_ident,
                    span = variant_ident.span()
                );
                
                // Store the field information for later use
                let fields_vec: Vec<Field> = named_fields.named.iter().cloned().collect();
                
                let field_defs = named_fields.named.iter().map(|field| {
                    let field_name = &field.ident;
                    let field_type = &field.ty;
                    quote! {
                        pub #field_name: #field_type,
                    }
                });

                let field_ref_defs = named_fields.named.iter().map(|field| {
                    let field_name = &field.ident;
                    let field_type = &field.ty;
                    quote! {
                        pub #field_name: &'target #field_type,
                    }
                });

                let field_mut_defs = named_fields.named.iter().map(|field| {
                    let field_name = &field.ident;
                    let field_type = &field.ty;
                    quote! {
                        pub #field_name: &'target mut #field_type,
                    }
                });

                // Generate the struct definitions
                let struct_definition = quote! {
                    #[derive(Debug, Clone, PartialEq)]
                    pub struct #struct_ident {
                        #(#field_defs)*
                    }
                };

                let struct_ref_definition = quote! {
                    pub struct #struct_ref_ident<'target> {
                        #(#field_ref_defs)*
                    }
                };

                let struct_mut_definition = quote! {
                    pub struct #struct_mut_ident<'target> {
                        #(#field_mut_defs)*
                    }
                };

                // The struct type becomes both full_field_type and inner_type
                let struct_type: Type = syn::parse_quote!(#struct_ident);
                let struct_ref_type: Type = syn::parse_quote!(#struct_ref_ident);
                let struct_mut_type: Type = syn::parse_quote!(#struct_mut_ident);
                let full_field_type = if let Some(_container) = container_ident {
                    // If container is specified, we would wrap it, but struct variants
                    // don't typically use containers. For now, treat as direct.
                    struct_type.clone()
                } else {
                    struct_type.clone()
                };

                variants_info.push(ParsedVariantInfo {
                    variant_ident,
                    token_ident,
                    full_field_type: Some(full_field_type),
                    inner_type: Some(struct_type),
                    is_unit: false,
                    is_struct: true,
                    struct_definition: Some(struct_definition),
                    struct_ref_definition: Some(struct_ref_definition),
                    struct_mut_definition: Some(struct_mut_definition),
                    ref_type: Some(struct_ref_type),
                    mut_type: Some(struct_mut_type),
                    struct_fields: Some(fields_vec),
                });
            }
            Fields::Unnamed(_) => {
                return Err(Error::new_spanned(
                    &variant.fields,
                    create_error_message(
                        "Tuple variant validation",
                        "only supports tuple variants with exactly one field"
                    ),
                ));
            }
        }
    }
    Ok(variants_info)
}

/// Helper function to extract the inner type from a container type
fn extract_inner_type(
    full_field_type: &Type,
    container_ident: &Option<Ident>,
) -> Result<Type, Error> {
    if let Some(container) = container_ident {
        // Attempt to extract T from Container<T>
        if let Type::Path(TypePath { path, .. }) = &full_field_type {
            if let Some(segment) = path.segments.last() {
                if segment.ident == *container {
                    if let PathArguments::AngleBracketed(args) =
                        &segment.arguments
                    {
                        if args.args.len() == 1 {
                            if let Some(GenericArgument::Type(ty)) =
                                args.args.first()
                            {
                                Ok(ty.clone())
                            } else {
                                Err(Error::new_spanned(
                                    args,
                                    "Container expects a type argument",
                                ))
                            }
                        } else {
                            Err(Error::new_spanned(
                                args,
                                "Container expects exactly one type argument",
                            ))
                        }
                    } else {
                        Err(Error::new_spanned(
                            segment,
                            "Container expects angle bracketed arguments",
                        ))
                    }
                } else {
                    Err(Error::new_spanned(
                        segment,
                        format!(
                            "Expected container type `{}`, found `{}`",
                            container, segment.ident
                        ),
                    ))
                }
            } else {
                Err(Error::new_spanned(path, "Cannot get path segment"))
            }
        } else {
            Err(Error::new_spanned(
                full_field_type,
                format!(
                    "Expected a path type matching container `{}`",
                    container
                ),
            ))
        }
    } else {
        // No container specified, the full type is the inner type
        Ok(full_field_type.clone())
    }
}

/// Validates the parsed named grouped matcher against the enum variants.
fn validate_grouped_matcher(
    parsed_grouped_matcher: &ParsedGroupedMatcher,
    parsed_variants: &[ParsedVariantInfo],
) -> Result<(), Error> {
    let mut all_grouped_variants = IndexSet::new();
    let mut duplicate_variant_check = IndexSet::new();
    let mut duplicate_group_name_check = IndexSet::new();
    let valid_variant_names: IndexSet<_> = parsed_variants
        .iter()
        .map(|v| v.variant_ident.to_string())
        .collect();

    for (group_name, group_variants) in &parsed_grouped_matcher.groups {
        // Check for duplicate group names
        if !duplicate_group_name_check.insert(group_name.to_string()) {
            return Err(Error::new_spanned(
                group_name,
                format!(
                    "Duplicate group name `{}` found in `grouped_matcher` attribute",
                    group_name
                ),
            ));
        }

        for variant_ident in group_variants {
            let variant_name = variant_ident.to_string();

            // Check if variant exists in the enum
            if !valid_variant_names.contains(&variant_name) {
                return Err(Error::new_spanned(
                    variant_ident, // Point to the specific identifier in the attribute
                    format!(
                        "Variant `{}` in group `{}` does not exist in the enum",
                        variant_name, group_name
                    ),
                ));
            }

            // Check if variant is already listed in another group
            if !duplicate_variant_check.insert(variant_name.clone()) {
                return Err(Error::new_spanned(
                    variant_ident,
                    format!(
                        "Variant `{}` is listed in multiple groups (`{}` and potentially others)",
                        variant_name, group_name
                    ),
                ));
            }
            all_grouped_variants.insert(variant_name);
        }
    }

    // Check if all enum variants are covered by the groups
    for variant_info in parsed_variants {
        if !all_grouped_variants
            .contains(&variant_info.variant_ident.to_string())
        {
            return Err(Error::new_spanned(
                &variant_info.variant_ident, // Point to the enum variant definition
                format!(
                    "Enum variant `{}` is not included in any group in the `grouped_matcher` attribute",
                    variant_info.variant_ident
                ),
            ));
        }
    }

    Ok(())
}

//============================================================================
// Helper Functions for Code Generation
//============================================================================

/// Generates macro-compatible paths for both tokens_path and dtype_variant_path.
/// Handles the case where paths start with "crate" and need to be converted to "$crate" for macro use.
fn generate_macro_compatible_paths(
    tokens_path: &Path,
    dtype_variant_path: &Path,
) -> (TokenStream2, TokenStream2) {
    let use_token_path_crate_macro = tokens_path
        .segments
        .first()
        .map(|seg| seg.ident == "crate")
        .unwrap_or(false);
    let use_dtype_variant_path_crate_macro = dtype_variant_path
        .segments
        .first()
        .map(|seg| seg.ident == "crate")
        .unwrap_or(false);

    let tokens_path_macro = if use_token_path_crate_macro {
        let mut rest_path = TokenStream2::new();
        for segment in tokens_path.segments.iter().skip(1) {
            rest_path.extend(quote!( :: #segment));
        }
        quote! { $crate #rest_path }
    } else {
        quote! { #tokens_path }
    };

    let dtype_variant_path_macro = if use_dtype_variant_path_crate_macro {
        quote! { $crate }
    } else {
        quote! { #dtype_variant_path }
    };

    (tokens_path_macro, dtype_variant_path_macro)
}

/// Generates local variant ZST token definitions when shared_variant_zst_path is not specified.
fn generate_local_token_definitions(
    parsed_variants: &[ParsedVariantInfo],
) -> TokenStream2 {
    let token_definitions = parsed_variants.iter().map(|v| {
        let token_ident = &v.token_ident;
        quote! {
            #[derive(Default, Debug)]
            pub struct #token_ident;
        }
    });

    quote! {
        #(#token_definitions)*
    }
}

/// Generates struct definitions for struct variants.
fn generate_struct_definitions(
    parsed_variants: &[ParsedVariantInfo],
) -> TokenStream2 {
    // Avoid intermediate Vec collections - use iterators directly
    let struct_definitions = parsed_variants
        .iter()
        .filter_map(|v| v.struct_definition.as_ref());

    let struct_ref_definitions = parsed_variants
        .iter()
        .filter_map(|v| v.struct_ref_definition.as_ref());

    let struct_mut_definitions = parsed_variants
        .iter()
        .filter_map(|v| v.struct_mut_definition.as_ref());

    quote! {
        #(#struct_definitions)*
        #(#struct_ref_definitions)*
        #(#struct_mut_definitions)*
    }
}

/// Generates From conversions for struct reference types to owned field structs.
fn generate_struct_from_conversions(
    parsed_variants: &[ParsedVariantInfo],
    enum_name: &Ident,
) -> TokenStream2 {
    let from_impls = parsed_variants
        .iter()
        .filter(|v| v.is_struct && v.struct_fields.is_some())
        .map(|v| {
            let variant_ident = &v.variant_ident;
            let struct_ident = format_ident!("{}{}Fields", enum_name, variant_ident);
            let struct_ref_ident = format_ident!("{}{}Ref", enum_name, variant_ident);
            let struct_mut_ident = format_ident!("{}{}Mut", enum_name, variant_ident);
            
            let fields = v.struct_fields.as_ref().unwrap();
            
            // Generate field conversions for Ref -> Fields
            let ref_field_conversions: Vec<_> = fields.iter().map(|field| {
                let field_name = field.ident.as_ref().unwrap();
                // Clone from reference - compiler optimizes Copy types automatically
                quote! { #field_name: src.#field_name.clone() }
            }).collect();
            
            // Generate field conversions for Mut -> Fields  
            let mut_field_conversions: Vec<_> = fields.iter().map(|field| {
                let field_name = field.ident.as_ref().unwrap();
                // Clone from reference - compiler optimizes Copy types automatically
                quote! { #field_name: src.#field_name.clone() }
            }).collect();
            
            // The consuming conversions still need to dereference since Ref/Mut structs contain references

            quote! {
                // From conversion for Ref types
                impl<'target> From<&'target #struct_ref_ident<'target>> for #struct_ident {
                    fn from(src: &'target #struct_ref_ident<'target>) -> Self {
                        Self {
                            #(#ref_field_conversions),*
                        }
                    }
                }

                // From conversion for Mut types
                impl<'target> From<&'target #struct_mut_ident<'target>> for #struct_ident {
                    fn from(src: &'target #struct_mut_ident<'target>) -> Self {
                        Self {
                            #(#mut_field_conversions),*
                        }
                    }
                }

                // Direct From conversion for Ref types (consuming)
                impl<'target> From<#struct_ref_ident<'target>> for #struct_ident {
                    fn from(src: #struct_ref_ident<'target>) -> Self {
                        Self {
                            #(#ref_field_conversions),*
                        }
                    }
                }

                // Direct From conversion for Mut types (consuming)
                impl<'target> From<#struct_mut_ident<'target>> for #struct_ident {
                    fn from(src: #struct_mut_ident<'target>) -> Self {
                        Self {
                            #(#mut_field_conversions),*
                        }
                    }
                }
            }
        });

    quote! {
        #(#from_impls)*
    }
}

/// Generates compile-time checks for shared token existence when using shared_variant_zst_path.
fn generate_token_validation(
    tokens_path: &Path,
    parsed_variants: &[ParsedVariantInfo],
) -> TokenStream2 {
    let validation_checks = parsed_variants.iter().map(|v| {
        let token_ident = &v.token_ident;
        // This code runs at compile time inside the const block.
        // If the path #tokens_path::#token_ident is invalid, compilation fails here.
        quote! { let _ = #tokens_path::#token_ident; }
    });

    quote! {
        // This const block forces compile-time evaluation of the checks inside.
        const _: () = {
            // Ensure the compiler knows about the crate containing the shared variant ZST tokens.
            // This validates that the tokens exist at the specified shared_variant_zst_path.
            #(#validation_checks)*
        };
    }
}

/// Generates `impl #dtype_variant_path::EnumVariantTarget<...>` blocks.
fn generate_enum_variant_downcast(
    dtype_variant_path: &Path,
    enum_name: &Ident,
    generics: &Generics,
    parsed_variants: &[ParsedVariantInfo],
    tokens_path: &Path, // Add tokens_path parameter
) -> TokenStream2 {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let downcast_impls = parsed_variants.iter().filter_map(|v| {
        if v.is_unit {
            return None;
        } // Skip unit variants
        let variant_ident = &v.variant_ident;
        let token_ident = &v.token_ident;
        let full_field_type = v.full_field_type.as_ref()?; // Should always be Some for non-unit

        // Add bounds ensuring the inner type and original lifetimes outlive the target lifetime
        let where_clause_with_bounds = where_clause.cloned().unwrap_or_else(|| WhereClause {
            where_token: Default::default(),
            predicates: Default::default(),
        });

        // Generate different patterns for tuple vs struct variants
        let (downcast_ref_pattern, downcast_mut_pattern, downcast_pattern) = if v.is_struct {
            // For struct variants, we need to construct/deconstruct the generated struct
            (
                quote! { Self::#variant_ident { .. } },
                quote! { Self::#variant_ident { .. } },
                quote! { Self::#variant_ident { .. } },
            )
        } else {
            // For tuple variants
            (
                quote! { Self::#variant_ident(field_payload) },
                quote! { Self::#variant_ident(field_payload) },
                quote! { Self::#variant_ident(field_payload) },
            )
        };

        // Generate different return expressions for struct vs tuple variants
        let (ref_return, mut_return, owned_return) = if v.is_struct {
            // For struct variants, we need to extract fields and construct the generated struct
            if let Some(fields) = &v.struct_fields {
                let struct_ident = format_ident!("{}{}Fields", enum_name, variant_ident);
                let struct_ref_ident = format_ident!("{}{}Ref", enum_name, variant_ident);
                let struct_mut_ident = format_ident!("{}{}Mut", enum_name, variant_ident);
                
                // Generate field patterns and bindings
                let field_patterns: Vec<_> = fields.iter().map(|f| {
                    let field_name = f.ident.as_ref().unwrap();
                    quote! { #field_name }
                }).collect();
                
                let field_constructions: Vec<_> = fields.iter().map(|f| {
                    let field_name = f.ident.as_ref().unwrap();
                    quote! { #field_name: #field_name.clone() }
                }).collect();

                let field_ref_constructions: Vec<_> = fields.iter().map(|f| {
                    let field_name = f.ident.as_ref().unwrap();
                    quote! { #field_name: #field_name }
                }).collect();

                let field_mut_constructions: Vec<_> = fields.iter().map(|f| {
                    let field_name = f.ident.as_ref().unwrap();
                    quote! { #field_name: #field_name }
                }).collect();
                
                (
                    // For reference downcasting, create reference wrapper struct
                    quote! {
                        if let Self::#variant_ident { #(#field_patterns),* } = self {
                            Some(#struct_ref_ident { #(#field_ref_constructions),* })
                        } else {
                            None
                        }
                    },
                    // For mutable reference downcasting, create mutable wrapper struct
                    quote! {
                        if let Self::#variant_ident { #(#field_patterns),* } = self {
                            Some(#struct_mut_ident { #(#field_mut_constructions),* })
                        } else {
                            None
                        }
                    },
                    // For owned downcasting, construct and return the struct
                    quote! {
                        if let Self::#variant_ident { #(#field_patterns),* } = self {
                            Some(#struct_ident { #(#field_constructions),* })
                        } else {
                            None
                        }
                    },
                )
            } else {
                // Fallback if field information is missing
                (quote! { None }, quote! { None }, quote! { None })
            }
        } else {
            // For tuple variants, simple field access
            (
                quote! { Some(field_payload) },
                quote! { Some(field_payload) },
                quote! { Some(field_payload) },
            )
        };

        // Use the full path to the token
        Some(if v.is_struct {
            // For struct variants, use the reference wrapper types
            let ref_target_type = v.ref_type.as_ref().unwrap();
            let mut_target_type = v.mut_type.as_ref().unwrap();
            
            quote! {
                // Implement the #dtype_variant_path::EnumVariantDowncast trait for owned downcasting
                impl #impl_generics #dtype_variant_path::EnumVariantDowncast<#tokens_path::#token_ident>
                    for #enum_name #ty_generics #where_clause_with_bounds
                {
                    type Target = #full_field_type;

                    fn downcast(self) -> Option<Self::Target> {
                        match self {
                            #downcast_pattern => #owned_return,
                            _ => None,
                        }
                    }
                }

                // Implement the #dtype_variant_path::EnumVariantDowncastRef trait for reference downcasting
                impl #impl_generics #dtype_variant_path::EnumVariantDowncastRef<#tokens_path::#token_ident>
                    for #enum_name #ty_generics #where_clause_with_bounds
                {
                    type Target<'target> = #ref_target_type<'target> where Self: 'target;

                    fn downcast_ref(&self) -> Option<Self::Target<'_>> {
                        match self {
                            #downcast_ref_pattern => #ref_return,
                            _ => None,
                        }
                    }
                }

                // Implement the #dtype_variant_path::EnumVariantDowncastMut trait for mutable reference downcasting
                impl #impl_generics #dtype_variant_path::EnumVariantDowncastMut<#tokens_path::#token_ident>
                    for #enum_name #ty_generics #where_clause_with_bounds
                {
                    type Target<'target> = #mut_target_type<'target> where Self: 'target;

                    fn downcast_mut(&mut self) -> Option<Self::Target<'_>> {
                        match self {
                            #downcast_mut_pattern => #mut_return,
                            _ => None,
                        }
                    }
                }
            }
        } else {
            // For tuple variants, use the field type directly (no lifetime parameters needed)
            quote! {
                // Implement the #dtype_variant_path::EnumVariantDowncast trait for owned downcasting
                impl #impl_generics #dtype_variant_path::EnumVariantDowncast<#tokens_path::#token_ident>
                    for #enum_name #ty_generics #where_clause_with_bounds
                {
                    type Target = #full_field_type;

                    fn downcast(self) -> Option<Self::Target> {
                        match self {
                            #downcast_pattern => #owned_return,
                            _ => None,
                        }
                    }
                }

                // Implement the #dtype_variant_path::EnumVariantDowncastRef trait for reference downcasting
                impl #impl_generics #dtype_variant_path::EnumVariantDowncastRef<#tokens_path::#token_ident>
                    for #enum_name #ty_generics #where_clause_with_bounds
                {
                    type Target<'target> = &'target #full_field_type where Self: 'target;

                    fn downcast_ref(&self) -> Option<Self::Target<'_>> {
                        match self {
                            #downcast_ref_pattern => #ref_return,
                            _ => None,
                        }
                    }
                }

                // Implement the #dtype_variant_path::EnumVariantDowncastMut trait for mutable reference downcasting
                impl #impl_generics #dtype_variant_path::EnumVariantDowncastMut<#tokens_path::#token_ident>
                    for #enum_name #ty_generics #where_clause_with_bounds
                {
                    type Target<'target> = &'target mut #full_field_type where Self: 'target;

                    fn downcast_mut(&mut self) -> Option<Self::Target<'_>> {
                        match self {
                            #downcast_mut_pattern => #mut_return,
                            _ => None,
                        }
                    }
                }
            }
        })
    });

    quote! { 
        #(#downcast_impls)* 
    }
}


/// Generates `impl #dtype_variant_path::EnumVariantConstraint<...>` blocks if `constraint` is specified.
fn generate_enum_variant_constraint(
    dtype_variant_path: &Path,
    enum_name: &Ident,
    generics: &Generics,
    parsed_variants: &[ParsedVariantInfo],
    constraint_opt: &Option<Expr>,
    tokens_path: &Path, // Add tokens_path parameter
) -> TokenStream2 {
    let constraint = match constraint_opt {
        Some(path) => path,
        None => return quote! {}, // No constraint specified
    };

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let constraint_impls = parsed_variants.iter().filter_map(|v| {
        if v.is_unit {
            return None;
        } // Skip unit variants
        let token_ident = &v.token_ident;
        let inner_type = v.inner_type.as_ref()?;

        // Add the constraint bound to the where clause
        let mut where_clause_with_bounds = where_clause.cloned().unwrap_or_else(|| WhereClause {
            where_token: Default::default(),
            predicates: Default::default(),
        });

        // Add constraint that inner_type implements the constraint_path
        where_clause_with_bounds
            .predicates
            .push(parse_quote!(#inner_type: #constraint));

        Some(quote! {
            // Implement #dtype_variant_path::EnumVariantConstraint for the enum with the token type
            // Use the full path to the token
            impl #impl_generics #dtype_variant_path::EnumVariantConstraint<#tokens_path::#token_ident>
                for #enum_name #ty_generics #where_clause_with_bounds
            {
                // Set the Constraint associated type to the inner type
                type Constraint = #inner_type;
            }
        })
    });

    quote! { #(#constraint_impls)* }
}

/// Generates `impl From<FieldType>` blocks.
fn generate_from_impls(
    enum_name: &Ident,
    generics: &Generics,
    parsed_variants: &[ParsedVariantInfo],
    has_container: bool,
    tokens_path: &Path,
    skip_from_impls: bool,
) -> TokenStream2 {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let payload_from_impls = parsed_variants.iter().filter_map(|v| {
        if v.is_unit {
            return None;
        } // Skip unit variants
        let variant_ident = &v.variant_ident;
        let full_field_type = v.full_field_type.as_ref()?; // Type in the variant tuple, e.g., Vec<u16> or f64
        let inner_type = v.inner_type.as_ref()?; // Inner type, e.g., u16 or f64

        if v.is_struct {
            // For struct variants, generate From<GeneratedStruct> -> EnumName
            // The from implementation needs to destructure the struct and construct the enum variant
            if let Some(fields) = &v.struct_fields {
                
                let field_constructions: Vec<_> = fields.iter().map(|f| {
                    let field_name = f.ident.as_ref().unwrap();
                    quote! { #field_name: value.#field_name }
                }).collect();
                
                Some(quote! {
                    impl #impl_generics From<#full_field_type> for #enum_name #ty_generics #where_clause {
                        fn from(value: #full_field_type) -> Self {
                            Self::#variant_ident { #(#field_constructions),* }
                        }
                    }
                })
            } else {
                None
            }
        } else if has_container {
            // When container is used, generate From<FullFieldType> -> EnumName
            Some(quote! {
                impl #impl_generics From<#full_field_type> for #enum_name #ty_generics #where_clause {
                    fn from(value: #full_field_type) -> Self {
                        Self::#variant_ident(value)
                    }
                }
            })
        } else {
            // When no container is used, full_field_type and inner_type are the same
            // So only generate one implementation
            Some(quote! {
                impl #impl_generics From<#inner_type> for #enum_name #ty_generics #where_clause {
                    fn from(value: #inner_type) -> Self {
                        Self::#variant_ident(value)
                    }
                }
            })
        }
    });

    // Generate From impls for unit variants converting from token types
    let unit_from_impls = parsed_variants.iter().filter_map(|v| {
        if !v.is_unit {
            return None;
        }
        let variant_ident = &v.variant_ident;
        let token_ident = &v.token_ident;

        Some(quote! {
            impl #impl_generics From<#tokens_path::#token_ident> for #enum_name #ty_generics #where_clause {
                fn from(_: #tokens_path::#token_ident) -> Self {
                    Self::#variant_ident
                }
            }
        })
    });

    // Check if all variants are unit types
    let all_unit_variants = parsed_variants.iter().all(|v| v.is_unit);

    // Generate from_variant implementation if all variants are unit types
    let from_variant_impl = if all_unit_variants {
        quote! {
            impl #impl_generics #enum_name #ty_generics #where_clause {
                /// Creates a new instance of the enum from a variant token.
                /// The variant token must implement Default.
                pub fn from_variant<V>() -> Self
                where
                    Self: From<V>,
                    V: Default,
                {
                    Self::from(V::default())
                }
            }
        }
    } else {
        quote! {}
    };

    if skip_from_impls {
        quote! {
            #from_variant_impl
            #(#unit_from_impls)*
        }
    } else {
        quote! {
            #(#payload_from_impls)*
            #(#unit_from_impls)*
            #from_variant_impl
        }
    }
}

/// Generates `downcast_ref`, `downcast_mut`, `downcast` methods using the #dtype_variant_path::EnumVariantDowncast trait.
fn generate_downcast_methods(
    dtype_variant_path: &Path,
    enum_name: &Ident,
    generics: &Generics,
    _parsed_variants: &[ParsedVariantInfo],
) -> TokenStream2 {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    quote! {
        impl #impl_generics #enum_name #ty_generics #where_clause {
            /// Attempts to downcast to a reference wrapper for the target type if the enum holds the
            /// variant corresponding to token type `Token`.
            pub fn downcast_ref<Token>(&self) -> Option<<Self as #dtype_variant_path::EnumVariantDowncastRef<Token>>::Target<'_>>
            where
                Self: #dtype_variant_path::EnumVariantDowncastRef<Token>
            {
                <Self as #dtype_variant_path::EnumVariantDowncastRef<Token>>::downcast_ref(self)
            }

            /// Attempts to downcast to a mutable reference wrapper for the target type if the enum holds the
            /// variant corresponding to token type `Token`.
            pub fn downcast_mut<Token>(&mut self) -> Option<<Self as #dtype_variant_path::EnumVariantDowncastMut<Token>>::Target<'_>>
            where
                Self: #dtype_variant_path::EnumVariantDowncastMut<Token>
            {
                <Self as #dtype_variant_path::EnumVariantDowncastMut<Token>>::downcast_mut(self)
            }

            /// Attempts to downcast to an owned target type if the enum holds the
            /// variant corresponding to token type `Token`, consuming the enum.
            /// Returns `Some(Target)` on success, or `None` if the enum doesn't hold the expected variant.
            pub fn downcast<Token>(self) -> Option<<Self as #dtype_variant_path::EnumVariantDowncast<Token>>::Target>
            where
                Self: #dtype_variant_path::EnumVariantDowncast<Token>,
                Self: Sized // Required for moving self
            {
                <Self as #dtype_variant_path::EnumVariantDowncast<Token>>::downcast(self)
            }
        }
    }
}

/// Generates a macro for pattern matching on enum variants if `matcher` name is provided.
/// **Uses `generate_match_arm_content`**.
fn generate_matcher_method(
    dtype_variant_path: &Path,
    enum_name: &Ident,
    _generics: &Generics, // Keep signature consistent, used by path closures
    parsed_variants: &[ParsedVariantInfo],
    matcher_ident: &Option<Ident>,
    tokens_path: &Path,
) -> TokenStream2 {
    let matcher_name = match matcher_ident {
        Some(ident) => ident,
        None => return quote! {}, // No matcher name specified
    };

    let all_unit_variants = parsed_variants.iter().all(|v| v.is_unit);
    let internal_matcher_name = format_ident!("_{}", matcher_name);

    // Generate macro-compatible paths
    let (tokens_path, dtype_variant_path) = generate_macro_compatible_paths(tokens_path, dtype_variant_path);

    let generate_macro_rule_arm = generate_macro_rule_arm(
        enum_name,
        parsed_variants,
        tokens_path.clone(),
        &dtype_variant_path,
        None,
    );

    // Generate all combinations of macro arms (same logic as before, calling the new generate_macro_arms)
    let macro_rule_arms = if all_unit_variants {
        vec![
            generate_macro_rule_arm(false, false, false, false, false, false),
            generate_macro_rule_arm(false, false, false, true, false, false),
            generate_macro_rule_arm(false, false, false, true, true, false),
            generate_macro_rule_arm(false, false, false, true, false, true),
            generate_macro_rule_arm(false, false, false, true, true, true),
        ]
    } else {
        vec![
            generate_macro_rule_arm(false, false, false, false, false, false),
            generate_macro_rule_arm(false, false, false, true, false, false),
            generate_macro_rule_arm(false, false, false, true, false, true),
            generate_macro_rule_arm(false, false, false, true, true, false),
            generate_macro_rule_arm(false, false, false, true, true, true),
            generate_macro_rule_arm(false, true, false, false, false, false),
            generate_macro_rule_arm(false, true, false, true, false, false),
            generate_macro_rule_arm(false, true, false, true, false, true),
            generate_macro_rule_arm(false, true, false, true, true, false),
            generate_macro_rule_arm(false, true, false, true, true, true),
            generate_macro_rule_arm(false, true, true, false, false, false),
            generate_macro_rule_arm(false, true, true, true, false, false),
            generate_macro_rule_arm(false, true, true, true, false, true),
            generate_macro_rule_arm(false, true, true, true, true, true),
            generate_macro_rule_arm(true, true, false, false, false, false),
            generate_macro_rule_arm(true, true, false, true, false, false),
            generate_macro_rule_arm(true, true, false, true, false, true),
            generate_macro_rule_arm(true, true, false, true, true, false),
            generate_macro_rule_arm(true, true, false, true, true, true),
            generate_macro_rule_arm(true, true, true, false, false, false),
            generate_macro_rule_arm(true, true, true, true, false, false),
            generate_macro_rule_arm(true, true, true, true, false, true),
            generate_macro_rule_arm(true, true, true, true, true, false),
            generate_macro_rule_arm(true, true, true, true, true, true),
        ]
    };

    let macro_arms = macro_rule_arms
        .into_iter()
        .map(
            |MacroRuleArm {
                 pattern_prefix_fragment,
                 pattern_suffix_fragment,
                 variant_bodies,
             }| {
                quote! {
                    ($value:expr, #pattern_prefix_fragment #pattern_suffix_fragment) => {
                        match $value {
                            #variant_bodies
                        }
                    };
                }
            },
        )
        .collect::<Vec<_>>()
        .into_iter()
        .fold(TokenStream2::new(), |mut acc, arm| {
            acc.extend(arm);
            acc
        });

    // --- Final Macro Definition ---
    quote! {
            #[doc(hidden)]
            #[macro_export]
            macro_rules! #internal_matcher_name {
                #macro_arms
            }
            #[allow(unused_imports)]
            pub use #internal_matcher_name as #matcher_name;
    }
}

/// Generates the grouped matcher macro if `grouped_matcher` is specified.
/// **Uses `generate_match_arm_content`**. Does NOT reuse `generate_macro_arms`.
/// Generates the grouped matcher macro if `grouped_matcher` is specified.
/// **Uses `generate_match_arm_content`**. Does NOT reuse `generate_macro_arms`.
fn generate_grouped_matcher_macro(
    dtype_variant_path: &Path,
    enum_name: &Ident,
    _generics: &Generics, // Keep signature consistent
    parsed_variants: &[ParsedVariantInfo],
    parsed_grouped_matcher: &ParsedGroupedMatcher,
    tokens_path: &Path,
) -> TokenStream2 {
    let macro_name = &parsed_grouped_matcher.macro_name;
    let groups = &parsed_grouped_matcher.groups;
    let internal_macro_name = format_ident!("_{}", macro_name);

    // Build maps for quick lookup: VariantIdent String -> VariantInfo and VariantIdent String -> Group Index
    let mut variant_info_map: IndexMap<String, &ParsedVariantInfo> =
        IndexMap::new();
    let mut variant_to_group_index: IndexMap<String, usize> = IndexMap::new();
    for (group_index, (_, group_variants)) in groups.iter().enumerate() {
        for variant_ident in group_variants {
            variant_to_group_index
                .insert(variant_ident.to_string(), group_index);
        }
    }
    for v in parsed_variants {
        variant_info_map.insert(v.variant_ident.to_string(), v);
    }

    // Generate macro-compatible paths
    let (tokens_path, dtype_variant_path) = generate_macro_compatible_paths(tokens_path, dtype_variant_path);

    // --- Define the Macro Rule ---
    let create_group_macro_arm = |include_src_ty: bool| {
        // Captures `macro!(value, [V1, V2] (inner) => { body0 }, [V3] => { body1 })`
        let group_pattern_arms = groups
            .iter()
            .enumerate()
            .map(|(group_index, (group_name, group_variants))| {
                let group_variants: Vec<ParsedVariantInfo> = group_variants
                    .iter()
                    .map(|ident| variant_info_map[&ident.to_string()])
                    .cloned()
                    .collect();

                let generate_macro_rule_arm = generate_macro_rule_arm(
                    enum_name,
                    &group_variants,
                    tokens_path.clone(),
                    &dtype_variant_path,
                    Some(group_index as _),
                );

                let all_unit_variants =
                    group_variants.iter().all(|info| info.is_unit);

                // #(#group_variants,)*
                let arm = if all_unit_variants {
                    generate_macro_rule_arm(
                        false, false, false, false, false, false,
                    )
                } else {
                    generate_macro_rule_arm(
                        include_src_ty,
                        true,
                        false,
                        false,
                        false,
                        false,
                    )
                };

                (group_name, arm)
            })
            .collect::<Vec<_>>();

        let group_match_pattern_fragment = {
            let fragments = group_pattern_arms.iter().map(|(name, arm)| {
                let prefix = &arm.pattern_prefix_fragment;
                let suffix = &arm.pattern_suffix_fragment;
                quote! {
                    #name : #prefix #suffix
                }
            });

            quote! {
                {
                    #(#fragments,)*
                }
            }
        };

        let all_bodies = {
            let ts = group_pattern_arms
                .iter()
                .map(|(_, arm)| &arm.variant_bodies);

            quote! {
                #(#ts,)*
            }
        };

        quote! {
            // Match the user's grouped input structure
            ( $value:expr, #group_match_pattern_fragment ) => {
                // Expand into the actual Rust match statement
                match $value {
                    #all_bodies // Expand the generated match arms here
                }
            };
        }
    };

    let pat1 = create_group_macro_arm(true);
    let pat2 = create_group_macro_arm(false);

    quote! {
        #[doc(hidden)]
        #[macro_export]
        macro_rules! #internal_macro_name {
            // Match the user's grouped input structure
            #pat1
            #pat2
        }
        #[allow(unused_imports)]
        pub use #internal_macro_name as #macro_name;
    }
}
